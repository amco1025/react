# 글수정 버튼 만들기
```
function App(){
  
  let [글제목, 글제목변경] = useState( ['남자코트 추천', '강남 우동맛집', '파이썬 독학'] );  
  
  return (
      <button onClick={ ()=>{ ??? } }> 수정버튼 </button>
  )
}
```

# 방법 1
```
function App(){
  
  let [글제목, 글제목변경] = useState( ['남자코트 추천', '강남 우동맛집', '파이썬 독학'] );  
  
  return (
    <button onClick={ ()=>{ 
      글제목변경(['여자코트 추천', '강남 우동맛집', '파이썬 독학'])
    } }> 수정버튼 </button>
  )
}
```

# 방법 2
```
function App(){
  
  let [글제목, 글제목변경] = useState( ['남자코트 추천', '강남 우동맛집', '파이썬 독학'] );  
  
  return (
    <button onClick={ ()=>{ 
      글제목[0] = '여자코트 추천';
      글제목변경(글제목)
    } }> 수정버튼 </button>
  )
}

하지만 이렇게 하면 변경이 되지 않는다.
이유는 뒤에서
또한 이렇게 하면 원본값이 보관되지 않는다.
```

# 방법 3
```
function App(){
  
  let [글제목, 글제목변경] = useState( ['남자코트 추천', '강남 우동맛집', '파이썬 독학'] );  
  
  return (
    <button onClick={ ()=>{ 
      let copy = [...글제목];
      copy[0] = '여자코트 추천';
      글제목변경(copy)
    } }> 수정버튼 </button>
  )
}

이렇게 하면 작동도 잘 되고 원본도 보관이 잘 된다.
```

# 이유

```
state 변경함수의 동작원리를 이해해야 한다.

1. state 변경함수는 기존 state == 신규state라면 state변경을 해주지 않는다. 

2. array/object의 경우 arr = [1,2,3] 이라고 작성하면 arr에 [1,2,3]을 저장하는 것이 아니라 [1,2,3]을 미지의 공간에 저장하고 arr에 [1,2,3]을 가리키는 화살표만 저장

따라서 방법 2의 경우 화살표가 가리키는 곳은 똑같으니까 state가 같다고 판단하여 변경하지 않는것.

```

```
let copy = [...글제목]
여기서 ...의 의미는

- 괄호를 벗긴다음에 다시 array로 만들어 주는것. 이렇게 하면 화살표가 달라져 새로운 array가로 인식. deep copy
```

# 가나다 순으로 정렬
```
return (
    <button onClick={ ()=>{ 
      let copy = [...글제목];
      copy.sort();
      글제목변경(copy)
    } }> 정렬버튼 </button>
  )
```